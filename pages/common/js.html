<?!= include('pages/common/renderers-js', context) ?>
<?!= include('pages/common/dt-editor-validator-js.html', context) ?>

<script>
  const context = JSON.parse("<?= JSON.stringify(context) ?>")
  const firebaseConfig = JSON.parse("<?= JSON.stringify(Instance.firebaseConfig) ?>")
  const TIMEZONE = "<?= TIMEZONE ?>"

  // Other global constants

  var users
  const global = {}
  var rtdb;

  // For use with date range picker on column search
  let DATE_RANGE_BOUNDS = {}

  const ROLES = [
    'admin',
    'adminAssistant',
    'loanOfficer',
    'juniorLoanOfficer',
    'loanOfficerManager',
    'processor',
    'processorAssistant',
    'processorManager',
    'pipelineManager',
    'postClosingManager'
  ]

  const UserIds = {
    TREVOR: 'L5VKYXK3',
    CATHERINE: 'L5VKZ0AU',
    BLAKE: 'L5VKYYJ7',
    CHANDLER: 'L5VKYYFG',
    CHANVOR: 'L5VKYZ9M',
    CAITLIN: 'L5VKZ07N',
  }

  const StatusId = context.statusId
  const StatusName = context.statusName
  const REQUIRED_STATUS_IDS_TO_CREATE_LOAN = context.requiredStatusIdsToCreateLoan

  const SubstatusId = context.substatusId

  const SourceId = {
    SELF_GEN: 'L5VL0QJJ',
    PAST_CLIENT: 'L5VL0PGW',
    REALTOR: 'L5VL0QOF',
    LENDER: 'L5VL0QMA',
    FINANCIAL_PLANNER: 'L5VL0QQF',
    MAILER: 'L5VL0Q9Y',
    TV: 'L5VL0PWH',
    PROSPECT: 'prospect'
  }
  

  const LoanPurpose = {
    REFI: "L5VKYIHY",
    H2H: "L5VKYIMC",
    PURCHASE: "L5VKYIDG",
    CONSTRUCTION: "L5VKYIV0"
  }

  const PROCESSING_STATUSES = [
    StatusId.PROCESSING,
    StatusId.UNDERWRITING,
    StatusId.CTC,
    StatusId.ON_HOLD,
  ]

  // Role filters for DataTable columns
  const Role = {
    ALL: {
      "admin": true,
      "loanOfficer": true,
      "processor": true,
      "pipelineManager": true,
      "businessDeveloper": true,
      "adminAssistant": true,
      "dev": true
    },
    ADMIN_ONLY: {
      "admin": true,
      "adminAssistant": true,
      "dev": true,
      "loanOfficer": false,
      "processor": false,
      "pipelineManager": false,
      "businessDeveloper": false
    },
    NONE: {
      "admin": false,
      "loanOfficer": false,
      "processor": false,
      "pipelineManager": false,
      "businessDeveloper": false
    }
  }

  const DATE_COLUMN_WIDTH = "5rem";
  const USER_COLUMN_WIDTH = "10rem";
  const CHECKBOX_COLUMN_WIDTH = "3rem";
  const DAYS_COLUMN_WIDTH = "4rem";
  const PERCENT_COLUMN_WIDTH = "4rem";
  const CURRENCY_COLUMN_WIDTH = "6rem";

  const DATE_FORMAT = "M/D/YY"
  const DATETIME_FORMAT = "M/D/YY h:mm:ss a"
  // We will store percents as integers, and divide them by this value to get a decimal
  const PERCENT_PRECISION = 1000000

  var expandedGroups = {}, expandAll = false;

  //  Max width (in characters) of text before truncating and displaying in a tooltip
  var MAX_TEXT_WIDTH = 25

  // These lead fields are also on the "loan figures" table of the loan object,
  // so we need to keep them in sync; the loan figures object knows which property to sync,
  // a change to any property in this list (on the lead) will trigger a sync of all of the synced loan figures
  const SYNCED_LOAN_FIGURES = [
    'rate', // interest rate
    'value', // price/value
    'loanAmount', // Initial Loan Balance
    'principalLimit',
    'interestRate', // We want to sync the following, but they are nested, so we just watch for interest rate
    // 'interestRate.expected.totalRate',
    // 'interestRate.initial.mip'
    // "interestRate.initial.margin"
  ]
  const fontAwesomeSpinner = '<div class="cactus-spinner"><i class="fas fa-spinner fa-spin"></i></div>'


  // Add timezone functionality to dayjs
  dayjs.extend(window.dayjs_plugin_utc)
  dayjs.extend(window.dayjs_plugin_timezone)
  dayjs.extend(window.dayjs_plugin_customParseFormat)
  dayjs.extend(window.dayjs_plugin_isBetween)
  // dayjs.extend(window.dayjs_plugin_isSameOrBefore)
  dayjs.extend(window.dayjs_plugin_quarterOfYear)
  dayjs.extend(window.dayjs_plugin_dayOfYear)
  DateTime.use(dayjs)

  // What statuses to show based on the 'leadType' url param.
  const STATUS_MAP = context.statusMap

  // Global event handlers
  $(document).ready(function ()
  {
    $(document).on('change', '.modal .modal-input[required]', onChangeModalInput)
    $(document).on("shown.bs.modal", '.modal', function ()
    {
      $(this).filter('.modal-input').removeClass('invalid')
    })
    $(document).on('click', '.modal-cancel', clearModalFormFields)

    $('.card .collapse').on('hide.bs.collapse', onHideCollapse)
    $('.card .collapse').on('show.bs.collapse', onShowCollapse)

    // This prevents popovers from closing when clicked inside, while using trigger: 'focus'
    // See https://stackoverflow.com/a/49025957
    // 4.29.23 However, it also prevents selecting text in the popover, AND we are now using trigger: 'click'
    // $('body').on('mousedown', '.popover', function (e)
    // {
    //   e.preventDefault()
    // });

    changeFontSize(0)
    $('#zoom-in-text').on('click', () => changeFontSize(2))
    $('#zoom-out-text').on('click', () => changeFontSize(-2))

    // Auto select text when editor field is clicked.
    $(document).on('focus', '.DTE_Field input[type="text"], .DTE_Field input[type="number"]',
      function ()
      {
        this.select()
      })
    // Close context menu when editor field is focused
    $(document).on('focus', '.DTE_Field input, .DTE_Field textarea',
      function ()
      {
        $('.dropdown-context').hide(100, function ()
        {
          $('.dropdown-context').css({ display: '' }).find('.drop-left').removeClass('drop-left');
        });
      })
  })

  // Update the base font size
  function changeFontSize(delta)
  {
    // Clamp between 10 and 24
    const FONT_SIZE_MIN = 10
    const FONT_SIZE_MAX = 24
    context.settings.fontSize = Math.min(
      Math.max(
        context.settings.fontSize + delta,
        FONT_SIZE_MIN
      ),
      FONT_SIZE_MAX
    )
    $('html').css('font-size', context.settings.fontSize + 'px')
    // Disable buttons if we've reached the limit
    $('#zoom-out-text').prop('disabled', context.settings.fontSize <= FONT_SIZE_MIN)
      .toggleClass('disabled', context.settings.fontSize <= FONT_SIZE_MIN)
    $('#zoom-in-text').prop('disabled', context.settings.fontSize >= FONT_SIZE_MAX)
      .toggleClass('disabled', context.settings.fontSize >= FONT_SIZE_MAX)

    // Store the property in user settings, if it has changed.
    if (Math.abs(delta) > Number.EPSILON)
      google.script.run.setUserSetting('fontSize', context.settings.fontSize)
  }


  function spinButtons(button)
  {
    $('.spinner-button')
      .each(function () 
      {
        const button = $(this)
        button.data('text', button.text())
      })
      .attr('disabled', 'disabled')
    if (button)
    {
      $(button).html(fontAwesomeSpinner)
    } else
    {
      $('.spinner-button').html(fontAwesomeSpinner)
    }
  }

  function unspinButtons()
  {
    $('.spinner-button').removeAttr('disabled')
      .each(function () 
      {
        const button = $(this)
        button.text(button.data('text'))
      })
  }


  function onHideCollapse(event)
  {
    $(this).closest('.card').find('i.collapse-toggle')
      .removeClass('fa-window-minimize')
      .addClass('fa-window-maximize')
  }

  function onShowCollapse(event)
  {
    $(this).closest('.card').find('i.collapse-toggle')
      .addClass('fa-window-minimize')
      .removeClass('fa-window-maximize')
  }

  function transferData()
  {
    google.script.run
      .withFailureHandler(somethingWentWrong)
      .withSuccessHandler(triggerTransferData)
      .fetchDashboardData()
  }

  function triggerTransferData(data)
  {

    $(document).trigger('data:transfer', data)
  }


  function onChangeModalInput(e)
  {
    var input = $(this)
    if (input.val()) input.removeClass('invalid')
  }


  function getEditorOptionsField(key, placeholder)
  {
    return {
      type: "select2",
      options: getEditorOptionsFieldOptions(key),
      opts: {
        allowClear: true,
        placeholder: {
          id: null,
          text: placeholder || '--'
        },
        dropdownAutoWidth: true
      }
    }
  }



  /**
   * The field for "file status" on the borrower tracker:
   * can include any substatus for processing, underwriting, or clear to close,
   * or can be funded or cancelled
   */
  function getProcessingSubstatusField(config = {})
  {
    return {
      name: 'lead.substatus',
      type: "select2",
      options: getProcessingSubstatusOptions(),
      opts: {
        allowClear: true,
        placeholder: {
          id: null,
          text: '--'
        },
        dropdownAutoWidth: true
      }
    }
  }

  function getProcessingSubstatusOptions()
  {
    let options = []
    // Processing, underwriting, or clear to close
    PROCESSING_STATUSES.forEach(ps =>
    {
      options = options.concat(
        Object.entries(context.options.status.options[ps].substatus)
          .map(([key, option]) => Object.assign(option, { key: key }))
          .sortBy('sequence', 'asc')
          .map(option =>
            ({ value: option.key, label: option.value })
          )
      )
    })

    // Include active lead statuses, as it appears active leads are sometimes also added to BT
    options.unshift({ value: 'preApp', label: 'Pre-App' })
    options.unshift({ value: 'LBN3JZUJ', label: 'Sent to Counseling' })
    options.unshift({ value: 'LBN3JZRA', label: 'Active Lead' })

    // Funded: this is the key for "Less than 3 months" but in this context the label "Funded" makes more sense
    options.push({ value: 'LBN3K1FF', label: 'Funded' })

    // Cancelled:
    options.push({ value: 'LBN3K2A7', label: 'Cancelled' })

    return options
  }

  function standardSelect2Field(name, options, placeholder)
  {
    // Are we passing array of strings or array of objects
    const option1Type = typeof options[0]

    return {
      name: name,
      type: "select2",
      options: option1Type === 'string' ?
        options.map(x => ({ value: x, label: x }))
        : options,
      opts: {
        allowClear: true,
        placeholder: {
          id: null,
          text: placeholder || '--'
        },
        dropdownAutoWidth: true
      }
    }
  }

  // Get the list of options, in DataTables editor format, for a given field
  function getEditorOptionsFieldOptions(key, options = {})
  {
    if (/user\./.test(key))
    {
      const role = key.split('.')[1]

      let userIds = Object.keys(context.users)
        .filter(id => context.users[id].active && context.users[id].roles[role])
      // If specified, filter for loan officers who are certified in a specific state
      if (options.state) userIds = userIds.filter(id => context.users[id].states && context.users[id].states[options.state])
      return userIds.map(id => ({ value: id, label: context.users[id].name }))
    } else
    {
      if (!context.options[key]) return []
      const choices = context.options[key].options
      // console.log('getEditorOptionsFieldOptions', choices, key)
      return Object.entries(choices)
        // Don't make it an option in the editor if it's been marked as inactive
        .filter(([key, option]) => option.active !== false)
        .map(([key, option]) => Object.assign(option, { key: key }))
        .sortBy('sequence', 'asc')
        .map(option =>
        {
          return { value: option.key, label: option.value }
        })
    }
  }


  /**
   * Supply a search function to each column
   */
  function createColumnSearchboxes(table)
  {
    // console.log("Creating searchboxes for table ", table);
    let tableNode = table.table().node()
    // Remove any existing search footer
    $(tableNode).find('tfoot.column-search-footer').remove()
    // Add the search footer
    const foot = $('<tfoot>')
      .insertAfter($(tableNode).find('thead'))
      .addClass('column-search-footer')
    table.columns().every(function (index, column)
    {
      // If searching customer service notes, apply the search to the combined customer service + client notes
      var column = this;
      const header = $(column.header())
      let title = header.text()
      let id = title.replace(/\s/g, '') + "-search";
      let footerCell = $('<th></th>');
      const columnInit = table.init().columns[index]
      // Non-visible columns are not in the DOM, so we don't want to add an element
      // We need the current visible state, not the initial state, because we call this again when columns are shown / hidden
      if (!column.visible()) return
      // If the column is not searchable, we still need to add an empty th
      foot.append(footerCell)
      if (columnInit?.searchable !== false)
      {
        const input = $('<input type="text" class="column-search-text" placeholder="Search '
          + title + '" id="'
          + id + '" />');
        footerCell.html(input)
        if (columnInit.filterByDate)
        {
          // console.log("Column %s filters by date", title);
          input.addClass('date-range-filter');
          setDateSearch(column, footerCell, columnInit)
        } else
        {
          input.addClass('column-search-text');
          setTextSearch(column, footerCell)
        }

        // If a search was passed in the url parameters, apply it now
        if (context.urlParams.searchColumn
          && context.urlParams.searchColumn === columnInit.name
          && context.urlParams.search)
        {
          input.val(context.urlParams.search).change();
        }
      }
    }); // For each column

    function setDateSearch(column, footerCell, options)
    {
      const input = $('input.date-range-filter', footerCell)
      if (input.length > 0)
      {
        const dataSource = column.dataSrc()
        const columnIndex = column.index()
        createColumnDateRangePicker(input, dataSource, options, tableNode)
        // TODO: This may be duplicated when we hide/show columns; find a way to avoid this
        $.fn.dataTable.ext.search.push(function (settings, searchData, dataIndex, rowData, counter)
        {
          // if (dataIndex !== columnIndex) return true;
          if (!DATE_RANGE_BOUNDS[dataSource]) return true;
          var date = searchData[columnIndex]
          // console.log(dataSource, date, columnIndex)
          // No value for this column? Filter it out.
          if (!date) return false;

          var min = DATE_RANGE_BOUNDS[dataSource].start
          var max = DATE_RANGE_BOUNDS[dataSource].end
          const include = min <= date && date <= max;
          console.log(`${min} <= ${date} <= ${max}? ${include}`)
          return include
        });
      }
    }

    function setTextSearch(column, footerCell)
    {
      // If the column currently has a search value (this will happen when we redraw the search boxes after adding or removing columns),
      // set the search box to that value
      const input = $('input.column-search-text', footerCell)
      const searchValue = column.search()
      if (searchValue)
      {
        input.val(searchValue)
          .addClass('active-search')
      }

      // Listener to trigger searching this column
      input.on('keyup change clear', function ()
      {
        if (column.search() !== this.value)
        {
          // Apply search and draw table.
          column.search(this.value).draw();

          // Highlight the search box when the search is active.
          $(this).toggleClass('active-search', Boolean(this.value))
        }
      });
    }
  }


  /**
   * Deprecated!  Prefer createColumnSearchBoxes
   * Apply a search function to each column
   * rowGroupOptions: .disableRowGroup, .rowGroupField
   * See https://datatables.net/examples/api/multi_filter.html
   *
   */
  function applyColumnSearchboxes(table)
  {
    table.columns().every(function ()
    {
      var column = this;
      // console.log("Column search", { columnfooter: column.footer(), colData: column.data(), value: this.value })

      $('input.column-search-text', this.footer()).on('keyup change clear', function ()
      {
        console.log({ colSearch: column.search(), val: this.value, columnHeader: $(column.header()).text() })
        if (column.search() !== this.value)
        // if (column.search() == this.value)
        {
          // Apply search and draw table.
          column.search(this.value).draw();

          // Highlight the search box when the search is active.
          $(this).toggleClass('active-search', Boolean(this.value))

        }
      });
      const filter = $('input.date-range-filter', this.footer())
      if (filter.length > 0)
      {
        const dataSource = column.dataSrc()
        const columnIndex = column.index()
        createColumnDateRangePicker(filter, dataSource)
        $.fn.dataTable.ext.search.push(function (settings, searchData, dataIndex, rowData, counter)
        {
          // if (dataIndex !== columnIndex) return true;
          if (!DATE_RANGE_BOUNDS[dataSource]) return true;
          var date = searchData[columnIndex]
          // console.log(dataSource, date, columnIndex)
          // No value for this column? Filter it out.
          if (!date) return false;

          var min = DATE_RANGE_BOUNDS[dataSource].start
          var max = DATE_RANGE_BOUNDS[dataSource].end

          return min <= date && date <= max;
        });
      }

    });
  }


  /**
   * Deprecated!  Prefer createColumnSearchBoxes
   * Add inputs in the "footer" of each column for searching
   */
  function setColumnSearchboxes(tableId, columns)
  {
    // console.log('setColumnSearchboxes', { tableId, columns })

    let footerRow = $("#" + tableId + " tfoot tr")
    if (!footerRow.get(0))
    {
      // create tfoot if it's not present
      let tableNode = $('#' + tableId)
      const foot = $('<tfoot>').insertAfter($(tableNode).find('thead'))
      console.log({ tableNode, foot })
      foot.append('<tr>')
      footerRow = $("#" + tableId + " tfoot tr")
    }

    // console.log('setColumnSearchboxes', { footerRow: footerRow.get(0) })


    columns.forEach(column =>
    {
      const th = $('<th></th>')
      if (column.searchable !== false)
      {
        if (column.filterByDate)
        {
          th.html(
            `<input type="text" class="date-range-filter" placeholder="Search ${column.title}" />`
          )
        }
        else
        {
          th.html('<input type="text" class="column-search-text" placeholder="Search ' + column.title + '" />')
        }
      }
      footerRow.append(th)
    })
  }


  function stripPhoneNumber(badFormatPhone)
  {
    if (!badFormatPhone) return ''
    let goodFormatPhone = badFormatPhone.toString().replace(/\D/g, '')
    return goodFormatPhone
  }

  /**
   * Render long text as truncated with the full text in the tooltip or popover
   * See https://datatables.net/forums/discussion/32240/how-to-implement-a-popup-tooltip-on-a-datatables-cell-that-displays-all-data
   * But we've chosen not to use bootstrap-style tooltips because they don't play well with datatables
   */
  function renderTruncated(text, type, rowData, meta, options = {})
  {
    const { condition } = options
    if (type === 'display' && typeof text === 'string')
    {
      if ($.fn.popover)
      {
        return `<div tabindex="0" class="table-popover text-truncate ${condition && condition(rowData)}" data-toggle="popover" data-html="true" data-trigger="hover"
          data-content='${text.replaceAll("'", "&apos;")}'>
          ${text}
          </div>`
      } else
      {
        return '<div class="text-truncate" title="' + text + '">' + text + '</div>'
      }
    } else
    {

      return text
    }
  }


  /**
   * Render long text as truncated with the full text in the tooltip or popover
   * The corresponding td must be set to position: relative for this to work
   */
  function renderWrapTruncated(text, type, rowData, meta)
  {
    if (type === 'display')
    {
      if ($.fn.popover)
      {
        // return `<div title="${text}" class="cell-wrap-truncate">${text}</div>`
        return `
        <div tabindex="0" class="table-popover cell-wrap-truncate" data-toggle="popover" data-html="true" data-trigger="hover"
          data-content='${text.replaceAll("'", "&apos;")}'>
          ${text}
          </div>
      `
      } else
      {
        return '<div class="cell-wrap-truncate" title="' + text + '">' + text + '</div>'
      }
    } else
    {
      return text
    }
  }

  /**
   * Get the next page of data
   */
  function fetchMoreData(functionName, args, dataTable, continuationToken)
  {
    if (continuationToken !== null)
    {
      google.script.run
        .withSuccessHandler(onLoadMoreData)
        .withFailureHandler(somethingWentWrong)
        .withUserObject({ 'functionName': functionName, 'args': args, 'dataTable': dataTable })
      [functionName](args, continuationToken);
    } else
    {
      hideLoadingData();
      if (context.urlParams.row) showRow(dataTable, context.urlParams.row);
      if (context.urlParams.rowgroup) showRowgroup(dataTable, context.urlParams.rowgroup)
    }
  }

  /**
   * Update the table with another page of data
   */
  function onLoadMoreData(result, config)
  {
    result = JSON.parse(result);

    // Assign 'select' property b/c DataTables doesn't like undefined values in objects
    result.data.forEach(function (row)
    {
      row.select = ''
    })
    config.dataTable
      .rows.add(result.data)
      .columns.adjust() // Auto-adjust column widths
      .draw(false);

    // For issues data only: store user emails
    if (result.users) users = result.users

    // Get next page
    fetchMoreData(config.functionName, config.args, config.dataTable, result.continuationToken);
  }

  function showRow(table, rowId)
  {
    try
    {
      var row = table.row('#' + rowId)
      // Go to page for this row
      row.show()
      // Expand only the row's rowgroup if it exists
      if (table.rowGroup().enabled())
      {
        expandedGroups = {}
        expandedGroups[row.data()[table.rowGroup().dataSrc()]] = true;
      }
      // Select row
      table.rows().deselect()
      row.select()

      // Draw table
      table.draw(false)

      // Attempt to scroll to row
      if (row.node()) row.node().scrollIntoView()

      // Click to expand child table if it exists
      $(row.node()).find('div.child-control').click()

    } catch (err)
    {
      console.warn("Unable to find row %s: %s", rowId, err.message)
    }
  }

  function showRowgroup(table, rowGroupId)
  {
    try
    {
      // Expand only the row's rowgroup if it exists
      if (table.rowGroup().enabled())
      {
        expandedGroups = {}
        expandedGroups[rowGroupId] = true;
      }

      // Draw table (we draw again below but in case the below fails:)
      table.draw(false)

      // Find any row in this group.
      var row = table.row('.rowgroup-' + rowGroupId)
      // Go to page for this row
      row.show().draw(false)

      // Attempt to scroll to row
      if (row.node()) row.node().scrollIntoView()

    } catch (err)
    {
      console.warn("Unable to find row group %s: %s", rowGroupId, err.message)
    }
  }

  function renderUserEmail(email)
  {
    return (email || '').toString().split('@')[0]
  }

  /**
   * Toggle the enabled/disabled status of toolbar buttons if rows are selected
   */
  function onSelectRows(e, dt, type, indexes)
  {
    // Apparently this gets triggered on, e.g. selection of text in the search inputs, not just on row selection.
    // By inspection, the row selection has namespace 'dt'
    if (e.namespace !== "dt") return;

    // Don't allow selection for rows pending payment
    if (e.type === 'select' && type === 'row')
    {
      var rows = dt.rows(indexes).nodes().to$();
      $.each(rows, function ()
      {
        if ($(this).hasClass('pending-payment')) table.row($(this)).deselect();
      })
    }
    // Disable/enable buttons based on number of rows selected
    // Selected rows. Not the same as rows, above, because we may have deselected
    var selectedRows = dt.rows('.selected').data().toArray();
    var selectionCount = selectedRows.length
    if (selectionCount === 0)
    {
      $('#dataTableToolbar button').attr('disabled', 'disabled')
      $('#dataTableToolbar button.always-enabled').removeAttr('disabled')
    } else
    {
      // Enable all buttons, then selectively disable those that don't apply, below
      $('#dataTableToolbar button').removeAttr('disabled')
    }

    // Some buttons only make sense if one row is selected
    if (selectionCount > 1)
    {
      $('#dataTableToolbar .single-selection-button').attr('disabled', 'disabled')
    }

    // Some buttons allow for multi selection but only if the rows are all services for the same client
    if (!selectedRows.every(function (row)
    {
      return row.clientidpass && row.clientidpass === selectedRows[0].clientidpass
    }))
    {
      $('#dataTableToolbar .same-client-selection-button').attr('disabled', 'disabled')
    }

    // Update status indicator for selection count
    $('#selectionCount').text(selectionCount)

  }

  var loadingSign = '' +
    '<div id="loading-sign-container" class="d-flex align-items-center justify-content-center" style="position: fixed; top: 0; bottom: 0; left: 0; right: 0; z-index: 500">' +
    '<div id="loading-sign-spinner" class="spinner-border " role="status"></div>' +
    '</div>';

  function showLoadingSign(parent = 'body', color = 'var(--loading-sign-color)', backgroundColor = 'rgba(0,0,0,.7)')
  {
    $('#cactus-alert').remove()
    var parentElement = $(parent)
    parentElement.append(loadingSign);
    $('#loading-sign-container').css('background-color', backgroundColor);
    $('#loading-sign-spinner').css('color', color);
  }

  function hideLoadingSign()
  {
    $('#loading-sign-container').remove();
  }

  function showLoadingSignOnModal(parent = 'body', color = 'white', backgroundColor = 'rgba(0,0,0,.7)')
  {
    var modalloadingSign = '' +
      '<div id="loading-sign-container" class="d-flex align-items-center justify-content-center" style="position: fixed; top: 0; bottom: 0; left: 0; right: 0; z-index: 1500">' +
      '<div id="loading-sign-spinner" class="spinner-border " role="status"></div>' +
      '</div>';
    var parentElement = $(parent)
    parentElement.append(modalloadingSign);
    $('#loading-sign-container').css('background-color', backgroundColor);
    $('#loading-sign-spinner').css('color', color);
  }

  var loadingData = '<div id="loading-data" class="alert alert-info">Loading data ...</div>'

  function showLoadingData()
  {
    $('#page-container').prepend(loadingData);
    $('#dataTableToolbar button').attr('disabled', 'disabled')
  }

  function hideLoadingData()
  {
    $('#loading-data').remove();
    // Don't enable buttons until rows are selected
    // $('#dataTableToolbar button').removeAttr('disabled')
    $('#dataTableToolbar button.always-enabled').removeAttr('disabled')
  }


  function removeAlerts()
  {
    $('#cactus-alert').remove()
  }

  /**
   * Show a bootstrap alert in a colored bar at the top of the page (or parent element).
   * options:
   *    message:
   *    parent: css selector for the parent element of the alert.  Defaults to '#page-container'
   *    type: Type of alert.  Determines the color scheme.  Defaults to 'info.'
   *              Can be 'info', 'success', 'danger' ('error'), 'warning', 'light','dark','primary','secondary'
   *    autoClose: boolean.  Defaults to true.
   *
   */
  function showAlert(options)
  {
    options = options || {}
    if (!options.message) return;

    // Close any previous alert:
    $('#cactus-alert').remove()

    // In case we forget that there isn't an error class.
    if (options.type == 'error') options.type = 'danger'

    // Default to info
    var alertClass = 'alert-' + (options.type || 'info')

    var closeButton = '' +
      '<button type="button" class="close" data-dismiss="alert" aria-label="Close">' +
      '<span aria-hidden="true">&times;</span>' +
      '</button>';

    var alertDiv = $('<div>')
      .attr('id', 'cactus-alert')
      .attr('class', 'alert alert-dismissible fade show')
      .addClass(alertClass)
      .attr('role', 'alert')
      .html(options.message)
      .attr('style', 'opacity: 90%; z-index: 950; white-space: pre-wrap;')
      .append(closeButton);

    // This usually follows a server-side call, so hide the loading sign.
    hideLoadingSign()
    unspinButtons()
    $(options.parent || '#page-container').prepend(alertDiv)
    // $('#cactus-alert').get(0).scrollIntoView();

    // Auto close after some seconds
    if (options.autoClose !== false)
    {
      setTimeout(
        function ()
        {
          alertDiv.alert('close');
        },
        10000
      );
    }
  }

  function showAlertOnModal(options)
  {
    options.parent = $('.modal:visible .modal-body')
    showAlert(options)
  }

  /**
   * Handle errors returned from server-side script.
   */
  function somethingWentWrong(err)
  {
    console.error(err.message)
    hideLoadingSign()
    unspinButtons()
    closeModal()
    showAlert({
      message: "Something went wrong:\n" + err.message,
      type: 'error',
      // Leave it open for purposes of reporting it
      autoClose: false
    })
  }

  /**
   * Handle errors returned from server-side script.
   */
  function somethingWentWrongOnModal(err)
  {
    console.error(err.message)
    hideLoadingSign()
    unspinButtons()
    showAlertOnModal({
      message: "Something went wrong:\n" + err.message,
      type: 'error',
      // Leave it open for purposes of reporting it
      autoClose: false
    })
  }

  /**
   * Used after a change in status:
   * Remove the selected rows from the table, and then display the alert
   */
  function removeSelectedRowsAndShowAlert(options, table)
  {
    console.log(JSON.stringify(options))
    clearModalFormFields()
    // De-select before removing, to trigger onSelectRows and update the selectionCount.
    table.rows('.selected').deselect().remove()
    table.columns.adjust()
    table.draw(false)
    showAlert(options)
  }

  /**
   * Used after a change in substatus:
   * Update the selected rows based on returned data, and then display the alert
   */
  function updateRowsAndShowAlert(config, table)
  {
    config = JSON.parse(config)
    clearModalFormFields()
    // Update rows
    if (config.updatedRows)
    {
      config.updatedRows.forEach(function (updatedRow)
      {
        var row = null, childTable = null;
        // MCL
        if (updatedRow.serviceId)
        {
          row = table.row('#' + updatedRow.serviceId)
        }
        // Pipeline
        else if (updatedRow.leadId)
        {
          row = table.row('#' + updatedRow.leadId)
        }
        if (row && row.length > 0)
        {
          row.data(updatedRow)
          assignColorClass(row.node(), row.data(), colorMap)
          childTable = $(row.child()).find('table').DataTable()
          if (childTable)
          {
            childTable.clear()
              .rows.add(updatedRow.serviceNotes)
              .draw();
          }
        }

      })
    }

    // Unselect and redraw table
    table.rows().deselect()
    table.columns.adjust()
    table.draw(false);

    // Alert
    showAlert(config)
  }


  /**
   * Append the returned rows, and then display the alert
   */
  function appendRowsAndShowAlert(config, table)
  {
    config = JSON.parse(config)
    clearModalFormFields()
    // Append rows
    if (config.appendRows)
    {
      table.rows.add(config.appendRows)
        // Assign color classes if specified
        .every(function ()
        {
          // 'this' = the row
          assignColorClass(this.node(), this.data(), colorMap)
        })
    }

    // Unselect and redraw table
    table.rows().deselect()
    table.columns.adjust()
    table.draw(false);

    // Alert
    showAlert(config)
  }

  /**
   * Clear all modal form fields so they are blank for next use.
   */

  function clearModalFormFields()
  {

    $('.modal-input').val('')
    $('.modal-input.form-check-input').prop('checked', false)
    var editor = tinymce.get('emailEditor')
    if (editor) editor.setContent("")
    $('#file').val("")
    $('.box label').html(noFileSelectedLabel)

    if (document.getElementById('my-awesome-dropzone'))
    {

      Dropzone.forElement('#my-awesome-dropzone').removeAllFiles(); // remove dropzone attachments
      $('#emailEditorIdsToDelete').val(''); // reset the email ID field
      $('#emailEditorFileIds').val('{}'); // reset the email ID field
    }
  }


  function assignColorClass(row, data, colorMap)
  {
    if (!colorMap) return;
    colorMap.forEach(function (mapping)
    {
      var colorTier
      if (mapping.tiers)
      {
        var colorValue = parseInt(data[mapping.field], 10)
        if (colorValue !== NaN)
        {
          colorTier = mapping.tiers.find(function (tier)
          {
            if (colorValue >= tier.minValue)
            {
              $(row).addClass(tier.priorityClass);
              return true
            } else
            {
              $(row).removeClass(tier.priorityClass)
              return false
            }
          })
        }
      } else if (mapping.classes)
      {
        colorTier = mapping.classes.find(function (colorClass)
        {
          if (data[mapping.field] === colorClass.value)
          {
            $(row).addClass(colorClass.priorityClass);
            return true
          } else
          {
            $(row).removeClass(colorClass.priorityClass)
            return false
          }
        })
      }
    })
  } // assignColorClass()


  function closeModal()
  {
    $(".modal").modal("hide");
  }

  function validateRequiredModalInputs()
  {
    var complete = true
    $('.modal-input').filter('input,textarea,select').filter('[required]:visible').each(function ()
    {
      var input = $(this)
      if (!input.val())
      {
        input.addClass('invalid')
        complete = false
      }
    })

    if (!complete) showAlert({
      'type': 'error',
      'message': 'The fields in red are required',
      'parent': $('.modal:visible .modal-body')
    })
    return complete
  }

  function getSelectedRowData()
  {
    return table.row('.selected').data()
  }

  function getSelectedRowsData()
  {
    return table.rows('.selected').data().toArray()
  }


  // Returns an Array of normalized Strings.
  // Empty Strings are returned for all Strings that could not be successfully normalized.
  // Arguments:
  //   - headers: Array of Strings to normalize
  function normalizeHeaders(headers)
  {
    return headers.map(normalizeHeader)
  }

  // Normalizes a string, by removing all alphanumeric characters and using mixed case
  // to separate words. The output will always start with a lower case letter.
  // This function is designed to produce JavaScript object property names.
  // Arguments:
  //   - header: string to normalize
  // Examples:
  //   "First Name" -> "firstName"
  //   "Market Cap (millions) -> "marketCapMillions
  //   "1 number at the beginning is ignored" -> "numberAtTheBeginningIsIgnored"
  function normalizeHeader(header)
  {
    var key = "";
    var upperCase = false;
    for (var i = 0; i < header.length; ++i)
    {
      var letter = header[i];
      if (letter == " " && key.length > 0)
      {
        upperCase = true;
        continue;
      }
      if (!isAlnum_(letter))
      {
        continue;
      }
      if (key.length == 0 && isDigit_(letter))
      {
        continue; // first character must be a letter
      }
      if (upperCase)
      {
        upperCase = false;
        key += letter.toUpperCase();
      } else
      {
        key += letter.toLowerCase();
      }
    }
    return key;
  }


  // Returns true if the character char is alphabetical, false otherwise.
  function isAlnum_(char)
  {
    return char >= 'A' && char <= 'Z' ||
      char >= 'a' && char <= 'z' ||
      isDigit_(char);
  }

  // Returns true if the character char is a digit, false otherwise.
  function isDigit_(char)
  {
    return char >= '0' && char <= '9';
  }

  /* Datatables Plug-ins */

  /* row().show(): https://datatables.net/plug-ins/api/row().show() */
  $.fn.dataTable.Api.register('row().show()', function ()
  {
    var page_info = this.table().page.info();
    // Get row index
    var new_row_index = this.index();
    // Row position
    var row_position = this.table()
      .rows({ search: 'applied' })[0]
      .indexOf(new_row_index);
    // Already on right page ?
    if ((row_position >= page_info.start && row_position < page_info.end) || row_position < 0)
    {
      // Return row object
      return this;
    }
    // Find page number
    var page_to_display = Math.floor(row_position / this.table().page.len());
    // console.log("Jumping to page %s", page_to_display)
    // Go to that page
    this.table().page(page_to_display)
    // Return row object
    return this;
  });

  function clearModalAndShowAlert(config)
  {
    clearModalFormFields()
    showAlert(config)
  }


  /**
   * Expand a table row when clicked, but not if a selection has been made, so we can copy or paste
   */
  function onClickTableRow()
  {
    var selection = window.getSelection();
    if (selection.toString().length > 0) return
    var row = $(this).parent()
    if (!row.hasClass('child-table')) row.toggleClass('expand-row')
  }

  /**
 * Show/hide a child table
 */
  function onClickDetailsControl(event)
  {
    var tr = $(this).closest('tr');
    var row = tr.closest('table').DataTable().row(tr);
    var rowData = row.data();

    // console.log('onClickDetailsControl', tr, row, rowData)
    if (row.child.isShown())
    {
      // This row is already open - close it
      row.child.hide();
      // Set icon
      // tr.find('.show-child-icon').addClass('fa-angle-right').removeClass('fa-angle-down')
    } else
    {
      // Open this row and set a data table
      row.child(event.data.childTableCreator(rowData)).show();
      // console.log('child table', rowData)
      // Create the DataTable instance
      let childTable = $(row.child()).find('table')
      // console.log('childTable', childTable)
      let childData = rowData[event.data.childKey]
      if (event.data.childSubkey) childData = childData[event.data.childSubkey]
      // console.log('trying to populate table', event.data.initOptions(childTable, rowData.leadId || rowData.fbKey), childData)

      if (childData && !Array.isArray(childData))
      {
        // childData must still be normal object

        childData = Object.entries(childData).map(([id, data]) =>
        {
          data.id = id
          return data
        })
      }

      // leadId and fbKey are both specific to two different schemas using onClickDetailsControl
      childTable.DataTable(event.data.initOptions(childTable, rowData.leadId || rowData.fbKey))
        .rows.add(childData || [])
        // .columns.adjust() // Auto-adjust column widths
        .draw(false);
      // Set icon
      // tr.find('.show-child-icon').removeClass('fa-angle-right').addClass('fa-angle-down')

      // LEAVE THIS AS lead-notes-table FOR GENERIC HANDLING
      if ($(childTable).hasClass('lead-notes-table'))
      {
        let childEditor = childTable.DataTable().editor()
        if (context.user.roles.admin)
        {
          // Delete row
          childTable.on('click', 'i.row-remove', function (e)
          {
            // console.log("Clicked remove row")
            childEditor.remove($(this).closest('tr'), false).submit()
          });
        }

        // Toggle row active/inactive
        childTable.on('click', 'i.row-toggle-active', function (e)
        {
          childEditor.edit($(this).closest('tr'), false)
          childEditor.set('active', childEditor.get('active') === false)
            .submit();
        });
      }

    }
  }

  /**
   * Convert a mysql timestamp (utc) to a dayjs in local timezone
   */
  function timestampToLocalDayjs(timestamp)
  {
    return dayjs.tz(timestamp, "UTC").tz(TIMEZONE)
  }

  function getUtcTimestamp(date)
  {
    return dayjs(date).tz('UTC').format('YYYY-MM-DD HH:mm:ss')
  }


  /**
   * Get the DataTable for the table with the given id
   * If id is not passed, return the DataTable with id 'table', or else the first datatable on the page.
   */
  function getDataTable(id)
  {
    if (id)
    {
      let selector = id[0] === '#' ? id : '#' + id
      if (!$.fn.DataTable.isDataTable(selector)) return null;
      return $(selector).DataTable();
    } else
    {
      if ($.fn.DataTable.isDataTable('#table'))
      {
        return $('#table').DataTable();
      } else
      {
        let tables = $('table').filter(function (index, element)
        {
          return $.fn.DataTable.isDataTable(element)
        })
        if (tables.length > 0)
        {
          return tables.first().DataTable()
        } else
        {
          return null
        }
      }
    }
  }


  /**
   * @param {Jquery} parent
   */
  function initializePopovers(parent)
  {
    // console.log("Initializing Popovers")
    // We get leftover popovers when we use the inline editor, so we destroy them here.
    $('body').find('div.popover.show').remove()
    parent = parent || $('body')
    parent.find('[data-toggle="popover"]')
      .popover({
        // trigger: 'focus',
        sanitize: false,
      })
    //
    parent.off("show.bs.popover")
    parent.on("show.bs.popover", function (e)
    {
      // hide all other (singleton experience)
      parent.find('[data-toggle="popover"]').not(e.target).popover("hide")
        .next('.popover').remove();
    });
  }

  /**
   * Populate a DataTable from an object, usually from Firebase
   */
  function populateTable(id, dataObject)
  {
    const formattedData = firebaseListToArray(dataObject)

    getDataTable(id).clear()
      .rows.add(formattedData)
      .draw()



  }

  // Set the key of each object as a property and return an array
  function firebaseListToArray(dataObject)
  {
    if (!dataObject)
    {
      return [];
    }
    return Object.entries(dataObject)
      .map(([k, v]) => Object.assign({ 'fbKey': k }, v))
  }

  /**
   * Validate required or conditionally required editor fields.
   * This can be called from the ajax function with validateEditorFields(this, success),
   * If a modification has been made to the editor code:
   * see https://datatables.net/forums/discussion/73987/get-editor-reference-within-editor-ajax-function#latest
   */
  function validateEditorFields(editor, success)
  {
    if (editor.mode() === 'remove') return true;
    const fieldErrors = []
    editor.order().forEach(fieldName =>
    {
      const field = editor.field(fieldName)
      const value = field.get()
      // No value? Check if required
      if ((value === null || value === '' || value === undefined))
      {
        // Absolutely required fields
        // Note field.s.opts is the set of options passed to the field.  This is not documented so may change in future versions.
        if ((field.s.opts.required || $(field.input()).attr('required')))
        {
          fieldErrors.push({ name: fieldName, status: 'Required' })
        }
        // Conditionally required fields
        // field.requiredIf should be a function where "this" is set to the editor instance, and returns a Boolean
        else if (typeof field.s.opts.requiredIf === 'function' && field.s.opts.requiredIf.call(editor))
        {
          fieldErrors.push({ name: fieldName, status: 'Required' })
        }
      }
    })
    if (fieldErrors.length > 0)
    {
      success({ 'fieldErrors': fieldErrors })
      console.log(fieldErrors)
      return false
    }
    return true
  }


  function validateInline(editor, data, success)
  {
    // No need to validate a deletion
    if (data.action === 'remove') return true;
    const fieldErrors = []
    for (var fieldName in Object.values(data.data)[0])
    {
      const field = editor.field(fieldName)
      const value = field.get()
      if ($(field.input()).attr('required') && (value === null || value === '' || value === undefined))
      {
        fieldErrors.push({ name: fieldName, status: 'Required' })
      }
    }
    if (fieldErrors.length > 0)
    {
      success({ 'fieldErrors': fieldErrors })
      return false
    }
    return true
  }


  /**
     * Handle tab change
     */
  function onShowTab(event)
  {
    // Remove any alerts, which foul up the tab changes.
    $('#cactus-alert').remove()

  }

  /**
     * Handle tab change
     */
  function onShownTab(event)
  {
    // Re-draw the data table on this tab (they don't draw nicely when not visible)
    // var tabFrom = $(event.relatedTarget)
    var tabTo = $(event.target)
    var tableName = tabTo.data('tablename')
    // console.log("Re-drawing table '%s'", tableName)

    $('#' + tableName).DataTable()
      .columns.adjust() // Auto-adjust column widths
      .draw(false);
  }

  /**
   * Get element with max value for key, from an array of objects
   * @param {Object[]} array
   * @param {string} key
   */
  function hasMaxOf(array, key)
  {
    let hasKey = array.find(x => x.hasOwnProperty(key));
    if (!hasKey)
    {
      return null
    }
    let max = hasKey[key]
    let hasMax = hasKey
    array.forEach(x =>
    {
      if (x[key] > max)
      {
        max = x[key];
        hasMax = x;
      }
    });
    return hasMax;
  }

  /**
   * Get max value for key, from an array of objects
   * @param {Object[]} array
   * @param {string} key
   */
  function maxOf(array, key)
  {
    let hasKey = array.find(x => x.hasOwnProperty(key));
    if (hasKey === null)
    {
      return null
    }
    let max = hasKey[key]
    array.forEach(x =>
    {
      if (x[key] > max)
      {
        max = x[key];
      }
    });
    return max;
  }

  /**
   * Sort an array of objects by a specific key
   * @param {string} key
   * @param {string} direction 'asc' or 'desc'; defaults to 'asc'
   * @returns {Object[]}  The array, sorted in place
   */
  if (!Array.prototype.sortBy)
  {
    Object.defineProperty(Array.prototype, 'sortBy', {
      value: function (key, direction)
      {
        let numericalDirection = (direction === 'desc') ? -1 : 1;
        return this.sort(function (a, b)
        {
          let aHasKey = (a.hasOwnProperty(key) && a[key] !== null && a[key] !== undefined)
          let bHasKey = (b.hasOwnProperty(key) && b[key] !== null && b[key] !== undefined)
          if (aHasKey && !bHasKey) return numericalDirection;
          if (!aHasKey && bHasKey) return (-1) * numericalDirection;
          if (!aHasKey && !bHasKey) return 0;
          if (a[key] > b[key]) return numericalDirection;
          if (a[key] < b[key]) return (-1) * numericalDirection;
          return 0
        });
      },
      configurable: true,
      writable: true
    });
  }

  function objectMatchesFilter(object, filter)
  {
    return Object.keys(filter).every(property =>
    {
      if (Array.isArray(filter[property]))
      {
        return filter[property].includes(object[property])
      }
      else
      {
        return object[property] === filter[property];
      }
    })
  }

  /**
   * Determine if a lead is for a reverse loan
   * @returns {Boolean} null if we don't have a loanType and thus don't know the loan direction
   */
  function isReverseLoan(lead)
  {
    if (lead.loanType)
    {
      let loanType = lead.loanType
      // console.log("The loan type of this loan is %s", loanType)
      let possibleLoanTypeOptions = context.options.loanType.options
      // console.log("Got all the possible options, which are %s", possibleLoanTypeOptions)
      return (possibleLoanTypeOptions[loanType]?.direction === "reverse")
    } else
    {
      return null
    }
  }

  function getLoanDirection(lead)
  {
    const isReverse = isReverseLoan(lead)
    if (isReverse === false)
    {
      return 'forward'
    } else if (isReverse === true)
    {
      return 'reverse'
    } else
    {
      return null
    }
  }

  /**
   * @param {Object} data The 'data' object passed by the ajax function,
   *                        OR a plain object with prop .target which defines the element where the spinner will be displayed.
   */
  function loadSpinner(data)
  {
    if (data && data.target)
    {
      $(data.target).addClass('d-none')
        .parent().append('<i class="fa fa-spinner fa-spin color-highlight"></i>')
    }
    else if (data && data.action === 'edit')
    {
      for (let id in data.data)
      {
        // If this is a row-reorder, place a spinner on the sequence column. The spinner will be removed upon re-rendering
        if (data.data[id].hasOwnProperty('sequence'))
        {
          $('#' + id).find('td.reorder').html('<i class="fa fa-spinner fa-spin color-highlight"></i>')
        }
      }

    } else if (data && data.action === 'remove')
    {
      for (let id in data.data)
      {
        $('#' + id + ' td.row-remove').find('i.fa-trash').addClass('fa-spinner').addClass('fa-spin').removeClass('fa-trash')
      }
    }
    // In any case, set a spinner on the confirmation icon
    $('.confirm-edit-icon.fa-check-circle').addClass('fa-spinner fa-spin').removeClass('fa-check-circle')
  }

  /**
   * Editor returns empty values as empty strings; we change them to null values.
   */
  function removeEmptyStrings(object)
  {
    if ("object" !== typeof object) return object;
    return Object.fromEntries(Object.entries(object).map(([key, value]) => [key, value === '' ? null : value]))
  }

  /**
   * When we update a rtdb node, nested objects are overwritten.
   * To avoid this, we use "multi-path updates"
   * See https://stackoverflow.com/a/33793367
   */
  function processNestedObjectForRtdbUpdate(object)
  {
    if ("object" !== typeof object) return object;
    return flattenObject(object, '/', true)
  }


  /**
  * Flatten a nested object by joining keys with dot notation or other seperator.
  * @param {Object} object
  * @param {string} prefix Used only in the recursion.  Doesn't need to be passed.
  * Example:
  * {mammals: {dogs: 4, cats: 3}, fish: {goldFish: 2}}
  * becomes
  * {mammals.dogs: 4, mammals.cats: 3, fish.goldFish: 2}
  */
  function flattenObject(object, separator = '.', flattenArrays = false, prefix)
  {
    var flatObject = {}
    for (var prop in object)
    {
      var flatProp = prefix ? prefix + separator + prop : prop;
      if (typeof object[prop] === 'object'
        && (flattenArrays || !(Array.isArray(object[prop]))))
      {
        Object.assign(flatObject,
          flattenObject(object[prop], separator, flattenArrays, flatProp))
      } else
      {
        flatObject[flatProp] = object[prop]
      }
    }
    return flatObject;
  }


  // Creates (nested) object based off dot notation key/values
  // @param {object} objectWithDotNotation, keys like "initial.margin.min": 3 will become {initial: { margin: { min: 3}}}
  function hydrateObject(objectWithDotNotation)
  {
    const data = {}

    Object.entries(objectWithDotNotation).forEach(([dotNotation, value]) =>
    {
      let relativeData = data
      const keySplit = dotNotation.split('.')
      // console.log(keySplit, relativeData)
      keySplit.forEach((key, i) =>
      {

        // console.log("hydrateObject", dotNotation, key, i != keySplit.length - 1, data, relativeData)
        if (!relativeData[key])
        {
          relativeData[key] = {}
        }
        if (i == keySplit.length - 1)
        {

          relativeData[key] = value
        }
        relativeData = relativeData[key]

      })
    })
    return data
  }


  function getObjectValue(object, dotNotation)
  {
    // console.log('getObjectValue', object, dotNotation)
    let relativeData = object
    const keySplit = dotNotation.split('.')
    let value
    keySplit.forEach((key, i) =>
    {
      if (i == keySplit.length - 1)
      {
        value = relativeData[key]
      } else
      {
        relativeData = relativeData[key]
      }
    })
    return value
  }

  /**
   * Given a lead, get a search link for the client portal page which it's on
   */
  function getClientPortalLink(lead, borrowerNames)
  {
    const searchValue = encodeURIComponent(borrowerNames || lead.borrowerId)
    return context.scriptUrl
      + `?page=leads&leadType=${getClientPortalPage(lead.status)}`
      + `&search=${searchValue}`
      + `&searchColumn=borrowerId`
  }

  // Get client portal page for a given lead status,
  // memoized to improve performance on the renderer
  const getClientPortalPage = (function ()
  {
    let pagesByLead = {}
    function f(x)
    {
      // Hard coded condition because Funded is viewed in multiple Client Portal pages
      if (x === StatusId.FUNDED)
      {
        pagesByLead[x] = "past"
      }

      if (!(x in pagesByLead))
      {
        pagesByLead[x] = Object.keys(STATUS_MAP)
          .find(k => x in STATUS_MAP[k])
      }
      return pagesByLead[x]
    }
    return f
  })()

  function renderDeleteAndVisibility(x, type, rowData, data)
  {
    if (type === 'display')
    {
      return '<div class="d-flex align-items-center"><i class="mr-1 row-toggle-active fas '
        + (rowData.active === false ? 'fa-eye-slash' : 'fa-eye')
        + ' small color-highlight-action icon-button"></i>'
        // Delete button only available to admin
        + (context.user.roles.admin ?
          '<i class="row-remove fa fa-times-circle small color-highlight-action icon-button"></i>'
          : '')
        + '</div>'
    } else return null
  }


  function getTableColNames(table)
  {

    const tableSettings = table?.settings()?.init()
    if (tableSettings?.columns)
    {
      return tableSettings.columns.map(e => e.name)
    } else
    {
      table = $(table.table().node())
      // console.log('debug table find', table)
      const TDElements = table.find('tbody tr:first').children()
      const columns = TDElements.map((i, el) => $(el).attr('data-editor-field')).toArray()
      console.log('get columns from editor fields of first row', columns)
      return columns
    }
  }

  /**
   * Create a date range picker for filtering a column
   * @param {Object} options .dateFilterFormat Optional format for the date; e.g. MM-DD if we want a year-insensitive comparison
   *                         .dateFilterDisplayFormat Optional format for displaying the date interval; 
   */
  function createColumnDateRangePicker(elem, dataSource, options = {}, tableSelector)
  {
    const input = $(elem)
    const filterFormat = options.dateFilterFormat || 'YYYY-MM-DD HH:mm:ss'
    const displayFormat = options.dateFilterDisplayFormat || 'M/D/YY'
    // Create daterangepicker
    const pickerOptions = {
      ranges: {
        'Month to Date': [moment().startOf('month'), moment().endOf('day')],
        'Last Month': [moment().subtract(1, 'months').startOf('month'), moment().subtract(1, 'month').endOf('month')],
        'Year to Date': [moment().startOf('year'), moment().endOf('day')],
        'Last Year': [moment().subtract(1, 'years').startOf('year'), moment().subtract(1, 'year').endOf('year')],
        'Clear Filter': [moment(0), moment(9999999999999)]
      },
      autoUpdateInput: false,
      opens: 'center',
      locale: {
        cancelLabel: 'Clear'
      },
      alwaysShowCalendars: true,
      // Default parentEl is body: this limits the picker to the right edge, whereas the table may go past the edge of the body
      // So we use the DataTables wrapper as the parent; I had to make a change to the date range picker code to make this work:
      // compare right edge of picker to right edge of document instead of window
      parentEl: $(tableSelector).closest('.dataTables_wrapper'),
    }
    if (DATE_RANGE_BOUNDS[dataSource])
    {
      pickerOptions.startDate = moment(DATE_RANGE_BOUNDS[dataSource].start)
      pickerOptions.endDate = moment(DATE_RANGE_BOUNDS[dataSource].end)
      input
        .val(pickerOptions.startDate.format(displayFormat) +
          '-' + pickerOptions.endDate.format(displayFormat)
            .addClass('active-search')
        )
    }
    input.daterangepicker(pickerOptions)//, cb);

    // Don't allow auto complete on the input, because it's not useful
    input.attr('autocomplete', 'off')

    input.on('apply.daterangepicker', function (ev, picker)
    {
      if (picker.startDate.valueOf('time') <= 0 && picker.endDate.valueOf('time') >= 9999999999999)
      {
        // Clear search
        $(this).val('')
          .removeClass('active-search');
        DATE_RANGE_BOUNDS[dataSource] = false
        // Set bounds to old ones for purpose of next filter
        picker.startDate = picker.oldStartDate;
        picker.endDate = picker.oldEndDate;
      } else
      {
        $(this)
          .val(picker.startDate.format(displayFormat) +
            '-' + picker.endDate.format(displayFormat)
          )
          .addClass('active-search');
        DATE_RANGE_BOUNDS[dataSource] = {
          start: picker.startDate.startOf('day').format(filterFormat),
          end: picker.endDate.endOf('day').format(filterFormat),
        }
      }

      // Redraw the table
      const table = tableSelector && $.fn.DataTable.isDataTable(tableSelector) ?
        $(tableSelector).DataTable() : getDataTable()
      table.draw(false)
    });

    input.on('cancel.daterangepicker', function (ev, picker)
    {
      $(this).val('')
        .removeClass('active-search');
      DATE_RANGE_BOUNDS[dataSource] = false
      const table = tableSelector && $.fn.DataTable.isDataTable(tableSelector) ?
        $(tableSelector).DataTable() : getDataTable()
      table.draw(false)
    });

  }

  // Supply this function as the createdRow option in DataTables, to style a summary row and avoid editing it
  function createdSummaryRow(row, data, dataIndex, cells)
  {
    if (data.dtBold)
    {
      $(row).addClass('font-weight-bold')
    }
    if (data.dtSummaryRow)
    {
      $(row).find('td').removeClass('cell-edit')
    }
  }


  const US_STATES = {
    "AL": "Alabama",
    "AK": "Alaska",
    // "AS": "American Samoa",
    "AZ": "Arizona",
    "AR": "Arkansas",
    "CA": "California",
    "CO": "Colorado",
    "CT": "Connecticut",
    "DE": "Delaware",
    "DC": "District Of Columbia",
    // "FM": "Federated States Of Micronesia",
    "FL": "Florida",
    "GA": "Georgia",
    // "GU": "Guam",
    "HI": "Hawaii",
    "ID": "Idaho",
    "IL": "Illinois",
    "IN": "Indiana",
    "IA": "Iowa",
    "KS": "Kansas",
    "KY": "Kentucky",
    "LA": "Louisiana",
    "ME": "Maine",
    // "MH": "Marshall Islands",
    "MD": "Maryland",
    "MA": "Massachusetts",
    "MI": "Michigan",
    "MN": "Minnesota",
    "MS": "Mississippi",
    "MO": "Missouri",
    "MT": "Montana",
    "NE": "Nebraska",
    "NV": "Nevada",
    "NH": "New Hampshire",
    "NJ": "New Jersey",
    "NM": "New Mexico",
    "NY": "New York",
    "NC": "North Carolina",
    "ND": "North Dakota",
    // "MP": "Northern Mariana Islands",
    "OH": "Ohio",
    "OK": "Oklahoma",
    "OR": "Oregon",
    // "PW": "Palau",
    "PA": "Pennsylvania",
    // "PR": "Puerto Rico",
    "RI": "Rhode Island",
    "SC": "South Carolina",
    "SD": "South Dakota",
    "TN": "Tennessee",
    "TX": "Texas",
    "UT": "Utah",
    "VT": "Vermont",
    // "VI": "Virgin Islands",
    "VA": "Virginia",
    "WA": "Washington",
    "WV": "West Virginia",
    "WI": "Wisconsin",
    "WY": "Wyoming"
  }


  // DataTable Helper function
  function getColumnsFrom(columnDefinitions, prependCheckbox = true)
  {
    const mappedColumns = columnDefinitions.map(def =>
    {
      const column = {
        name: def.name,
        ...def.table
      }
      if (def.table)
      {
        return column
      }
    }).filter(Boolean)

    if (prependCheckbox)
    {

      return [{
        name: 'select',
        className: 'select-checkbox',
        searchable: false
      }, ...mappedColumns]
    } else
    {
      return mappedColumns
    }
  }

  // DataTable helper function
  function getFieldsFrom(columnDefinitions)
  {
    return columnDefinitions.map(def =>
    {
      const field = {
        name: def.name,
        ...def.field
      }
      if (def.field)
      {
        if (def.field.required && field.label)
        {
          field.label = field.label + " *"
        }
        return field
      }
    }).filter(Boolean)
  }


  /**
 * Get a shorter uid than the one provided by Utilities.getUuid()
 * This one is just the current time in milliseconds converted to base36, plus 4 random characters
 * To avoid the unlikely case of collisions, we allow for a "seed" to be appended
 */
  function getUid(seed = "")
  {
    var now = new Date()
    var time = now.getTime()
    var uid = time.toString(36).toLocaleUpperCase()
      + "-"
      // 4 random characters in case we generate two uids in the same millisecond (1679615 = 36^4 - 1)
      + Math.round((Math.random() * 1679615)).toString(36).toLocaleUpperCase()
      + seed
    console.log("Generated uid %s", uid)
    return uid;
  }


  // /*
  //    * Ajax function for updating Firestore db
  //    * @param {string} collectionName
  //    */
  // function firestoreAjax(data, success, error, collectionName, callback)
  // {
  //   console.log(data)
  //   success({ data: [] })
  //   switch (data.action)
  //   {
  //     case 'remove':
  //       Object.keys(data.data).forEach(id =>
  //         firestore.deleteDoc(firestore.doc(firestore.db, collectionName, id)))
  //       break
  //     case 'create':
  //       for (const id of Object.keys(data.data))
  //       {
  //         firestore.addDoc(
  //           firestore.collection(firestore.db, collectionName),
  //           data.data[id]
  //         )
  //       }
  //       break
  //     case 'edit':
  //       Object.keys(data.data).forEach(id =>
  //         firestore.updateDoc(
  //           firestore.doc(firestore.db, collectionName, id),
  //           processNestedObjectForFirestoreUpdate(data.data[id])
  //         ))
  //       break
  //     default:
  //       throw new Error("Unrecognized editor action: %s", data.action)
  //   }
  //   if (callback)
  //   {

  //     callback(data)
  //   }
  // }

  function googleScriptRun(functionName, ...args)
  {
    return new Promise((resolve, reject) =>
    {
      showLoadingSign()
      // console.log('trying to run ', functionName, ...args)
      google.script.run
        .withSuccessHandler((...response) =>
        {
          hideLoadingSign()
          resolve(...response)
        })
        .withFailureHandler(reject)
      [functionName](...args)
    })
  }

  function getTableColumnIndexFunction(tableColumns)
  {
    return function getTableColumnIndex(name)
    {
      return tableColumns.findIndex(el => el.name == name)
    }
  }

  /**
   * Get the order property for a DataTables configuration, based on the column names
   * @param {Object[]} Array of column configs, as passed to $().DataTables()
   * @param {Array[]} Like the order property, but with column names instead of indices
   * @returns {Array[]} The order property, with indices
   * Example: getColumnOrder(columns, [['name', 'asc'],['occupation', 'asc']]) => [[1, 'asc'],[3, 'asc']]
   */
  function getColumnOrder(columns, order)
  {
    return order.map(x =>
    {
      const columnIndex = columns.findIndex(column => column.name === x[0])
      if (columnIndex === -1) throw new Error(`Error in getColumnOrder: No column named ${x[0]}`)
      return [columnIndex, x[1] || 'asc']
    })
  }

</script>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.13.0/firebase-app.js";
  import * as FIREBASE_DATABASE from "https://www.gstatic.com/firebasejs/9.13.0/firebase-database.js"

  // Initialize Firebase
  const FIREBASE_APP = initializeApp(firebaseConfig);

  /* Real-time database */
  const DATABASE = FIREBASE_DATABASE.getDatabase(FIREBASE_APP);
  // Some convenience functions
  const dbRef = (path) => FIREBASE_DATABASE.ref(DATABASE, path)

  rtdb = {
    ref: dbRef,
    onValue: (path, callback) => FIREBASE_DATABASE.onValue(dbRef(path), callback),
    remove: (path) => FIREBASE_DATABASE.remove(dbRef(path)),
    update: (path, object) => FIREBASE_DATABASE.update(dbRef(path), object),
    push: (path, object) => FIREBASE_DATABASE.push(dbRef(path), object),
    set: (path, object) => FIREBASE_DATABASE.set(dbRef(path), object),
    get: (path) => FIREBASE_DATABASE.get(dbRef(path)),
    db: DATABASE,
    rtdb: FIREBASE_DATABASE
  }

</script>